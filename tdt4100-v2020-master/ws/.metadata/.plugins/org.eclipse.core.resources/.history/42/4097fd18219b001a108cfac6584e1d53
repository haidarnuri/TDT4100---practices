package Eksamen2019;

import java.util.Comparator;
import java.util.function.Predicate;

public class EmergencyPriorityTreatmentUnit extends AbstractTreatmentUnit{

	@Override
	public boolean startTreatment(Doctor doctor) {
		if(noAvailableDoctors()) {
	 		   return false;
	 	  }	 	 
	 	Patient highestPriority = getPatientWithHighestPri();
	 	
	 	//filterer ut leger som ikke har kompetanse til å kurere pasienten. 
	 	//Antar at en ratio på over 0 er en start for å hjelpe pasienten
	 	Doctor anyDoctor = getDoctorWhoCanHelp(highestPriority);
	 	
		if(anyDoctor==null) {
			System.out.println("The hospital has no Doctors");
			return false;
			
		}else {
			//Første metoden fjerner evt pasienter vedkommenden har fra før 
			anyDoctor.setPatient(null);
			anyDoctor.setPatient(highestPriority);
			anyDoctor.treat();
			return true; 
		}
	}
	

	
	@Override
	public boolean startTreatment(Patient patient) {
		Patient highestPriority = getPatientWithHighestPri();
	 	
	 	//filterer ut leger som ikke har kompetanse til å kurere pasienten. 
	 	//Antar at en ratio på over 0 er en start for å hjelpe pasienten
	 	Doctor anyDoctor = getDoctorWhoCanHelp(highestPriority);
	 	if(highestPriority.equals(patient)) {
	 		Doctor availableDoctor = getDoctorWhoCanHelp(patient);
		 	availableDoctor.setPatient(null);
		 	availableDoctor.setPatient(patient);
		 	availableDoctor.treat();
		 	return true;
		}else {
		 	return false;
		}
	}
	
	private Patient getPatientWithHighestPri() {
		return getWaitingPatients().stream()
								   .max(Comparator.comparing(patient->patient.getPriority()))
								   .get();
	}
	
	//Forskjellen på denne og forrige er at her itererer jeg gjennom listen med alle leger. 
	private Doctor getDoctorWhoCanHelp(Patient highestPriority) {
		return getAllDoctors().stream()
				 .filter(doc->doc.canTreat(highestPriority)>0)
				 .findFirst().orElse(null);
	}
}
