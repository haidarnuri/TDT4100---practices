package Eksamen2019;

import java.util.Comparator;

public class TreatmentUnit extends AbstractTreatmentUnit implements DoctorAllocator{
 
	 public boolean startTreatment(final Doctor doctor) {   // 1c
		   boolean startTreatment = false;
		   if(noAvailableDoctors()) {
			   return startTreatment;
		   }
		   //Tenker at når legen har fått tildelt en pasient så stopper jeg prossesen. Nok med en av gangen   
		   
		  
		  doctor.setPatient(patient);
		  doctor.treat();
		  startTreatment=true;
		  break;
			  
	       
		   return startTreatment;
		}


	   /**
	    * Finds an available doctor for the provided patient, and sets that doctor to
	* treat the patient.
	    * @param patient the patient for which a treating doctor should be found.
	    * @return true if a doctor for the provided patient was found, false
	* otherwise.
	    */
	  
	   public boolean startTreatment(final Patient patient) {   // 1c
		   boolean startTreatment = false;
		   if(noAvailableDoctors()) {
			   return startTreatment;
		   }
		   Doctor docThatTreat = allocateDoctor(patient, this);
		   validateDoctor(docThatTreat);
		   docThatTreat.setPatient(patient);
		   docThatTreat.treat();
		   startTreatment=true;
	 	   return startTreatment;   
	   }
       
    private Patient patient1 = new Patient();
    private Doctor doctor1 = new Doctor();
    
    /**
	    * Finds the patient in the TreatmentUnit that the provided doctor
	    * should start treating.
	    * Note: The method should be free of side effects, i.e. should not modify any object.
	    * @param doctor
	    * @param treatmentUnit
	    * @return the patient that the doctor should treat, or null.
	    */
    
	@Override
	public Patient allocatePatient(Doctor doctor, TreatmentUnit treatmentUnit) {
		Patient getHighPriPatient = getWaitingPatients().stream()
		  												.filter(patient -> treatmentUnit.getWaitingPatients().contains(patient))
		  												.filter(p -> doctor.canTreat(p)>0)
		  												.max(Comparator.comparing(Patient::getPriority))
		  												.get();
		return getHighPriPatient;
	}

	
	
	   
    /**
   * Finds the doctor in the TreatmentUnit that the provided patient
   * should be treated by.
   * Note: The method should be free of side effects, i.e. should not modify any object.
   * @param patient
   * @param treatmentUnit
   * @return The doctor that should treat the provided patient, or
   * null if none was found.
   */

	@Override
	public Doctor allocateDoctor(Patient patient, TreatmentUnit treatmentUnit) {
			Doctor treatingDoctor= getAvailableDoctors().stream()
										 .filter(doctor -> treatmentUnit.getAllDoctors().contains(doctor))
										 .filter(doc->doc.canTreat(patient)>0)
										 .findFirst().orElse(null);
		return treatingDoctor;
	}
       
	
	private void validateDoctor(Doctor docThatTreat) {
		if(docThatTreat==null) {
			throw new IllegalArgumentException("There is noe doctor who can treat this patient");
	}
		
	private void validatePatient(Patient patient) {
		if(patient==null) {
			throw new IllegalArgumentException("There is noe doctor who can treat this patient");
	}
	}
	   
}
       
       
       
       
       
       
       
       
       
       
       
       
