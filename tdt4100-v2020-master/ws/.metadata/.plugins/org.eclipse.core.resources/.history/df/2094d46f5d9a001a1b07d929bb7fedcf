package Eksamen2019;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;

/**
 * A class for managing a set of doctors and the patients they're treating.
 * When doctors or patients arrive, it is made sure that patients are treated as soon as possible.
 */
public class TreatmentUnit {
 
		private Collection<Doctor> allDoctors = new ArrayList<Doctor>();
		//Antar at alle pasienter som er i denne samlingen venter på behandling. 
		private Collection<Patient> allPatients = new ArrayList<Patient>();
		
       /**
        * Adds a doctor and makes sure s/he starts treating a patient, if one is waiting.
        * @param doctor
        */
       public void addDoctor(final Doctor doctor) {  // 1b
            validateDoctor(doctor);
    	   	if(!allDoctors.contains(doctor)) {
            	 allDoctors.add(doctor);
             } 
    	   	startTreatment(doctor);    	   	
       }
 
 
       /**
        * @return the currently available doctors
        */
       public Collection<Doctor> getAvailableDoctors() {  // 1b
    	   Collection<Doctor> availableDoctors = new ArrayList<>();
    	   allDoctors.stream()
    	   			 .filter(doctor -> doctor.isAvailable())
    	   			 .forEach(doctor->availableDoctors.add(doctor));
    	   return availableDoctors;             
       }
      
       public void addPatient(final Patient patient) {  // 1b
           	validatePatient(patient);
           	if(!allPatients.contains(patient)) {
           		allPatients.add(patient);
           	}
           	startTreatment(patient);
        }
 
 
       /**
        * @param pred the predicate that the doctor must satisfy
        * @return some doctor satisfying the predicate
        */
       public Doctor getDoctor(final Predicate<Doctor> pred) {  // 1b
              Doctor tempDoctor = allDoctors.stream()
            		  						.filter(pred)
            		  						.findAny().orElse(null);
              return tempDoctor;
       }
 
 
       /**
        * Find the doctor, if any, that treats the provided patient.
        * @param patient
        * @return the doctor treating the provided patient, or null, of the patient isn't currently being treated
        */
       public Doctor getDoctor(final Patient patient) {  // 1b
              Doctor doctor = null;
    	   	  for(Doctor doc:allDoctors) {
            	  if(doc.getPatient().equals(patient)) {
            		  doctor=doc;
            	  }
              }
    	   	  return doctor;
       }
 
 
       /**
        * Find all patients that are not currently being treated.
        * @return the patients not currently being treated.
        */
       public Collection<Patient> getWaitingPatients() {  // 1b
              final Collection<Patient> result = new ArrayList<>();
              allPatients.stream()
              			 .filter(patient -> getDoctor(patient)==null)
              			 .forEach(patient -> result.add(patient));
              return result;
       }
 
       /**
        * Finds a waiting patient and sets him/her as the provided doctor's patient.
        * @param doctor the doctor for which a patient to treat should be found
        * @return true if a patient for the provided doctor was found, false
        * otherwise.
        */
       private boolean startTreatment(final Doctor doctor) {   // 1c
    	   boolean startTreatment = false;
    	   if(noAvailablePatientsOrDoctors()) {
    		   return startTreatment;
    	   }
    	   //Tenker at når legen har fått tildelt en pasient så stopper jeg prossesen. Nok med en av gangen   
    	   for(Patient patient:getWaitingPatients()) {
           	  doctor.setPatient(patient);
           	  startTreatment=true;
           	  break;
           }
    	   return startTreatment;
    	}
 
 
       /**
        * Finds an available doctor for the provided patient, and sets that doctor to
 * treat the patient.
        * @param patient the patient for which a treating doctor should be found.
        * @return true if a doctor for the provided patient was found, false
 * otherwise.
        */
       private boolean startTreatment(final Patient patient) {   // 1c
    	   boolean startTreatment = false;
    	   if(noAvailablePatientsOrDoctors()) {
    		   return startTreatment;
    	   }
    	   for(Doctor doc:getAvailableDoctors()) {
              doc.setPatient(patient);
           	  startTreatment=true;
           	  break;
           }
     	   return startTreatment;   
       }
 
 
       /**
        * Removes the link between doctor and patient, after treatment is finished.
        * Since the patient is fully treated, s/he is removed from this treatment
 * unit.
        * Also ensure the doctor starts treating another patient.
        * @param doctor the doctor that has finished treating his/her patient.
        */
       public void treatmentFinished(final Doctor doctor) {  // 1c
            if(!doctor.isAvailable()) {
            	allPatients.remove(doctor.getPatient());
            	doctor.setPatient(null);
            	startTreatment(doctor);
            }
       }
       
       //Alle private metoder under her.
       private void validateDoctor(Doctor doctor) {
    	   if(doctor==null) {
    		   throw new IllegalArgumentException("This doctor does not exist");
    	   }
       }
       
      	private void validatePatient(Patient patient) {
      		 if(patient==null) {
      		   throw new IllegalArgumentException("This patient does not exist");
      	   }
      	}
      	
      	private boolean noAvailablePatientsOrDoctors() {
      		return getWaitingPatients().isEmpty() || getAvailableDoctors().isEmpty();
      	}


       
       
       public static void main(String[] args) {
		
       }
       
       
}
       
       
       
       
       
       
       
       
       
       
       
       
