package Eksamen2019;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public abstract class AbstractTreatmentUnit {
	private Collection<Doctor> allDoctors = new ArrayList<Doctor>();
	private Collection<Patient> allPatients = new ArrayList<Patient>();
	
   /**
    * Adds a doctor and makes sure s/he starts treating a patient, if one is waiting.
    * @param doctor
    */
   public void addDoctor(final Doctor doctor) {  // 1b
        validateDoctor(doctor);
	   	if(!allDoctors.contains(doctor)) {
        	 allDoctors.add(doctor);
        	 startTreatment(doctor); 
         } 
	   	   	   	
   }


   /**
    * @return the currently available doctors
    */
   public Collection<Doctor> getAvailableDoctors() {  // 1b
	   Collection<Doctor> availableDoctors = new ArrayList<>();
	   availableDoctors = allDoctors.stream()
	   			 					.filter(doctor -> doctor.isAvailable())
	   			 					.collect(Collectors.toList());
	   return availableDoctors;             
   }
  
   public void addPatient(final Patient patient) {  // 1b
       	validatePatient(patient);
       	if(!allPatients.contains(patient) && patient.requiresTreatment()) {
       		allPatients.add(patient);
       		startTreatment(patient);
       	}
   }


   /**
    * @param pred the predicate that the doctor must satisfy
    * @return some doctor satisfying the predicate
    */
   public Doctor getDoctor(final Predicate<Doctor> pred) {  // 1b
          Doctor tempDoctor = allDoctors.stream()
        		  						.filter(pred)
        		  						.findAny().orElse(null);
          return tempDoctor;
   }


   /**
    * Find the doctor, if any, that treats the provided patient.
    * @param patient
    * @return the doctor treating the provided patient, or null, of the patient isn't currently being treated
    */
   public Doctor getDoctor(final Patient patient) {  // 1b
          Doctor doctor = getDoctor(doc->doc.getPatient().equals(patient));
	   	  return doctor;
   }


   /**
    * Find all patients that are not currently being treated.
    * @return the patients not currently being treated.
    */
   public Collection<Patient> getWaitingPatients() {  // 1b
          final Collection<Patient> result = new ArrayList<>();
          allPatients.stream()
          			 .filter(patient -> patient.requiresTreatment())
          			 .forEach(patient -> result.add(patient));
          return result;
   }

   /**
    *Antar at leger som kan behandle minst en tilstand får tildelt pasienten, men at pasienten er i systemet 
    *så lenge vedkommende har ubehandlede tilstander. 
    */
  
   public abstract boolean startTreatment(final Doctor doctor) ;



   /**
    * Finds an available doctor for the provided patient, and sets that doctor to
* treat the patient.
    * @param patient the patient for which a treating doctor should be found.
    * @return true if a doctor for the provided patient was found, false
* otherwise.
    */
  
   public abstract boolean startTreatment(final Patient patient) ;

   /**
    * Removes the link between doctor and patient, after treatment is finished.
    * Since the patient is fully treated, s/he is removed from this treatment
* unit.
    * Also ensure the doctor starts treating another patient.
    * @param doctor the doctor that has finished treating his/her patient.
    */
   public void treatmentFinished(final Doctor doctor) {  // 1c
        if(!doctor.isAvailable()) {
        	//Legger til en betingelse til som sjekker om pasienten er blitt helt kurert
        	//Ellers så blir den satt i kø for å vente på en annen lege/spesialist som kan kurere resterende behov
        	if(!doctor.getPatient().requiresTreatment()) {
        		allPatients.remove(doctor.getPatient());
        	}
        	startTreatment(doctor.getPatient());
        	doctor.setPatient(null);
        	startTreatment(doctor);
        	
        }
   }
   
   //Alle private metoder under her.
   private void validateDoctor(Doctor doctor) {
	   if(doctor==null) {
		   throw new IllegalArgumentException("This doctor does not exist");
	   }
   }
   
  	protected void validatePatient(Patient patient) {
  		 if(patient==null) {
  		   throw new IllegalArgumentException("This patient does not exist");
  	   }
  	}
  	
  	protected boolean noAvailableDoctors() {
  		return getAvailableDoctors().isEmpty();
  	}


}
