package Eksamen2019;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * A class for managing a set of doctors and the patients they're treating.
 * When doctors or patients arrive, it is made sure that patients are treated as soon as possible.
 */
public class TreatmentUnit {
 
		private Collection<Doctor> allDoctors = new ArrayList<Doctor>();
		private Collection<Patient> allPatients = new ArrayList<Patient>();
		
       /**
        * Adds a doctor and makes sure s/he starts treating a patient, if one is waiting.
        * @param doctor
        */
       public void addDoctor(final Doctor doctor) {  // 1b
            validateDoctor(doctor);
    	   	if(!allDoctors.contains(doctor)) {
            	 allDoctors.add(doctor);
             } 
    	   	startTreatment(doctor);    	   	
       }
 
 
       /**
        * @return the currently available doctors
        */
       public Collection<Doctor> getAvailableDoctors() {  // 1b
    	   Collection<Doctor> availableDoctors = new ArrayList<>();
    	   availableDoctors = allDoctors.stream()
    	   			 					.filter(doctor -> doctor.isAvailable())
    	   			 					.collect(Collectors.toList());
    	   return availableDoctors;             
       }
      
       public void addPatient(final Patient patient) {  // 1b
           	validatePatient(patient);
           	if(!allPatients.contains(patient)) {
           		allPatients.add(patient);
           	}
           	startTreatment(patient);
        }
 
 
       /**
        * @param pred the predicate that the doctor must satisfy
        * @return some doctor satisfying the predicate
        */
       public Doctor getDoctor(final Predicate<Doctor> pred) {  // 1b
              Doctor tempDoctor = allDoctors.stream()
            		  						.filter(pred)
            		  						.findAny().orElse(null);
              return tempDoctor;
       }
 
 
       /**
        * Find the doctor, if any, that treats the provided patient.
        * @param patient
        * @return the doctor treating the provided patient, or null, of the patient isn't currently being treated
        */
       public Doctor getDoctor(final Patient patient) {  // 1b
              Doctor doctor = getDoctor(doc->doc.getPatient().equals(patient));
    	   	  return doctor;
       }
 
 
       /**
        * Find all patients that are not currently being treated.
        * @return the patients not currently being treated.
        */
       public Collection<Patient> getWaitingPatients() {  // 1b
              final Collection<Patient> result = new ArrayList<>();
              allPatients.stream()
              			 .filter(patient -> patient.requiresTreatment())
              			 .forEach(patient -> result.add(patient));
              return result;
       }
 
       /**
        *Antar at leger som kan behandle minst en tilstand får tildelt pasienten, men at pasienten er i systemet 
        *så lenge vedkommende har ubehandlede tilstander. 
        */
       private boolean startTreatment(final Doctor doctor) {   // 1c
    	   boolean startTreatment = false;
    	   if(noAvailablePatientsOrDoctors()) {
    		   return startTreatment;
    	   }
    	   //Tenker at når legen har fått tildelt en pasient så stopper jeg prossesen. Nok med en av gangen   
    	   
    	   for(Patient patient:getWaitingPatients()) {
    		  if(doctor.canTreat(patient)>0) {
    			  doctor.setPatient(patient);
    			  doctor.treat();
    			  startTreatment=true;
    			  break;
    		  }
           }
    	   return startTreatment;
    	}
 
 
       /**
        * Finds an available doctor for the provided patient, and sets that doctor to
 * treat the patient.
        * @param patient the patient for which a treating doctor should be found.
        * @return true if a doctor for the provided patient was found, false
 * otherwise.
        */
       private boolean startTreatment(final Patient patient) {   // 1c
    	   boolean startTreatment = false;
    	   if(noAvailablePatientsOrDoctors()) {
    		   return startTreatment;
    	   }
    	   for(Doctor doc:getAvailableDoctors()) {
              if(doc.canTreat(patient)>0) {
            	doc.setPatient(patient);
            	doc.treat();
           	  	startTreatment=true;
           	  	break;
              }
           }
     	   return startTreatment;   
       }
 
 
       /**
        * Removes the link between doctor and patient, after treatment is finished.
        * Since the patient is fully treated, s/he is removed from this treatment
 * unit.
        * Also ensure the doctor starts treating another patient.
        * @param doctor the doctor that has finished treating his/her patient.
        */
       public void treatmentFinished(final Doctor doctor) {  // 1c
            if(!doctor.isAvailable()) {
            	//Legger til en betingelse til som sjekker om pasienten er blitt helt kurert
            	//Ellers så blir den satt i kø for å vente på en annen lege/spesialist som kan kurere resterende behov
            	if(!doctor.getPatient().requiresTreatment()) {
            		allPatients.remove(doctor.getPatient());
            	}
            	doctor.setPatient(null);
            	startTreatment(doctor);
            }
       }
       
       //Alle private metoder under her.
       private void validateDoctor(Doctor doctor) {
    	   if(doctor==null) {
    		   throw new IllegalArgumentException("This doctor does not exist");
    	   }
       }
       
      	private void validatePatient(Patient patient) {
      		 if(patient==null) {
      		   throw new IllegalArgumentException("This patient does not exist");
      	   }
      	}
      	
      	private boolean noAvailablePatientsOrDoctors() {
      		return getWaitingPatients().isEmpty() || getAvailableDoctors().isEmpty();
      	}


       
       
       public static void main(String[] args) {
		
       }
       
       
}
       
       
       
       
       
       
       
       
       
       
       
       
